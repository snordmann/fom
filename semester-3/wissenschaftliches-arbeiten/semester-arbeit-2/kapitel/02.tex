\newpage
\section{Microservice Architekturen} \label{msa}

% Im Kapitel \ref{msa} wird zunächst die MSA erklärt und in die allgemeinen
% Software Architektur eingeordnet. Auch wiord in diesem Kapitel die Monolithische
% Architektur vorgestellt und mit der MSA kontrastiert.

MSA ist ein Architekturmuster für verteilte Systeme, das ein Informationssystem
in viele Services aufteilt. Die einzelnen Services sind lose miteinander
gekoppelt, wodurch unabhängige Entwicklung und Bereitstellung des Services
ermöglicht werden.

\subsection{Definition von Microservice Architekturen}

Um eine schlüssige Definition von MSA zu geben, stützt sich dieser Arbeit auf
die Ansichten von Martin Fowler und James Lewis. Fowler ist ein Autor mehrerer Bücher zum Thema
Softwarearchitektur\footnote{TODO: Referenzen einfügen} und wird bei
wissenschaftlichen Arbeiten mit Peer-Review zitiert\footnote{TODO: Referenzen
einfügen}.

Auf seinem Blog nennen Fowler und Lewis folgende Eigenschaften von
MSA\footnote{https://www.martinfowler.com/articles/microservices.html}:

\begin{enumerate}
      \item \textbf{Komponenten als Services}\label{components-as-service} \\
            Softwareeinheiten, die unabhängig von anderen entwickelt und
            ausgetauscht werden können, werden nicht als Bibliothek (=in-memory
            Funktionen), sondern als Service, der außerhalb des Prozesses laufen und
            über Web Service Requests und Remote Procedure Calls aufgerufen werden, bereitgestellt
      \item \textbf{Organisation um Unternehmensfunktionen}\label{organization-around-function} \\
            Teams werden nicht nach Fachbereich (bspw. Frontend, Backend,
            Datenbanken), sondern nach Unternehmensfunktion organisiert
      \item \textbf{Produkte, nicht Projekte} \\
            Es gibt keine Trennung zwischen Entwicklung des Services und dessen
            Betrieb. Beides wird aus der selben Organisationseinheit geleistet
      \item \textbf{Schlaue Endpunkte und dumme Verbindungen}\label{smart-endpoints-dump-pipes} \\
            Die Kommunikation zwischen den Services ist so einfach wie möglich. Ein
            Anti-Pattern ist es Logik zum Routen oder Transformieren der Nachricht
            in den Message Broker zu abstrahieren.
      \item \textbf{Dezentralisierte Steuerung} \\
            Es gibt wenige IT Standard, an die die Teams gebunden sind. Stattdessen
            werden best practice Lösungen eigenständig erarbeitet und verbreitet.
      \item \textbf{Dezentralisierte Datenverwaltung}\label{decentralized-data} \\
            Jeder Service hat seine eigene Datenbank
      \item \textbf{Infrastrukturautomatisierung}\label{automatisierung} \\
            Viele Prozesse der Entwicklung und Bereitstellung von Services sind
            automatisiert. Automatisierte Tests geben Vertrauen und automatisierte
            Bereitstellung hilft gegen menschliches Versagen
      \item \textbf{Design für Fehlerresistenz} \\
            Die Services sind so geschrieben, dass sie Fehler in anderen Services
            aushalten können
      \item \textbf{Evolutionäres Design} \\
            Die Auswahl, Größe und Grenzen eines Services können sich über die Zeit
            verändern, um besser verwaltbar zu sein
\end{enumerate}

Diese Liste stammt aus dem Jahr 2013 und ist in einigen Aspekten veraltet.
Dennoch bietet sie eine gute Grunddefinition für diese Arbeit. Die Hauptaspekte,
auf die sich die Arbeit hauptsächlich beziehen wird, sind gleich geblieben:
\ref{components-as-service} Komponenten als Services,
\ref{organization-around-function} Organisation um Unternehmensfunktionen,
\ref{decentralized-data} Dezentralisierte Datenhaltung und
\ref{automatisierung} Infrastrukturautomatisierung sind noch immer zentrale Bestandteile, während die
anderen Punkte eher Best-Practices sind, wenn Microservices in Unternehmen
eingesetzt werden.

\subsection{Vergleich zu Monolithen}\label{compare-monolith}

In vielen Arbeiten und auch bei der Definition von Fowler und Lewis werden
Microservices - ein Architekturmuster für verteilte Systeme - mit Monolithen -
einem nicht verteiltem System - verglichen.

Bei Monolithen handelt es sich um ein Architekturparadigma bei dem alle
Komponenten für ein Informationssystem auf einem Server laufen (Vgl. Punkt
\ref{components-as-service}). Auch wenn einige Funktionen außerhalb des Servers
laufen, kann es noch immer als Monolith kategorisiert werden: Es werden
beispielsweise häufig Datenbanken auf anderen Servern betrieben.

Fowler argumentiert, dass jede Applikation als Monolith anfangen sollte, weil es
schwierig ist, eine funktionale MSA von Grund auf aufzubauen. Bei neuen
Applikationen seien viele Faktoren unklar: Wird die Applikation später wirklich
genutzt, Was soll die Applikation können, Aus welchen Komponenten wird die
Applikation später bestehen?

Durch diese Unklarheiten und den Mehraufwand für die Verwaltung der MSA, starten viele
Applikationen als Monolith.

Die Frage ist nun, warum Applikationen überhaupt von Monolithen zu MSA wechseln
sollten. Der Hauptgrund ist die fehlende Skalierbarkeit von Monolithen. Weil
Team in einer gemeinsamen Codebase\footnote{dt.} arbeiten, gibt es beim
Zusammenführen (mergen) verschiedener APplikationsfunktionen häufig
Probleme\footnote{Referenz zu Mergefests; eg. Phoenix Project} wegen der
unvorhergesehenen Interaktionen verschiedener Subsysteme.

Neben der Skalierbarkeit der Entwicklung ist auch die Skalierbarkeit der
Laufzeitumgebung bei Monolithen ein häufiges Problem. Monolithen werden zu einem
einzigen Softwarepaket geschnürt und deployt\footnote{dt.}. Häufig heißt das,
dass die Applikation nur vertikal skalieren kann, d.h. dass Ressourcen, wie CPU,
RAM oder IOPS an das laufende System hinzugefügt werden müssen, anstatt, dass
eine weitere Instanz gestartet wird.

%

% \subsubsection{Komponenten als Services}

% Fowler beschreibt Komponenten als eine Softwareeinheit, die unabhängig von
% anderen Komponenten ausgetauscht und geupgraded werden kann. Traditionell werden
% diese Komponenten als Bibliothek bereitgestellt. Laut Fowler sind Bibliotheken
% Komponenten, die im Programm gelinkt sind und über in-memory Funktionen
% aufgerufen werden. Services hingegen sind Komponenten, die außerhalb des
% Prozesses laufen und über Mechanismen wie Web Service Aufrufe oder \ac{RPC}
% aufgerufen werden.

% Fowler nennt die unabhängige Deploybarkeit als zentralen Vorteil von Services
% gegenüber Bibliotheken. Um eine Bibliothek zu aktualisieren muss der komplette
% Hauptprozess inklusive anderer Bibliotheken neu bereitgestellt werden. Bei
% Services kann jeder Service unabhängig von den anderen aktualisiert werden -
% vorrausgesetzt die \ac{API} verändert sich nicht.

% Natürlich gibt es auch Nachteile von Services gegenüber Bibliotheken. Laut
% Fowler sind RPC teurer als Zugriffe über den geteilten Speicher. Ebenfalls ist
% die Migration von Funktionen von einem Service zum anderen schwieriger.


% https://www.martinfowler.com/articles/microservices.html#ComponentizationViaServices
% https://www.martinfowler.com/articles/microservice-trade-offs.html
% https://www.martinfowler.com/bliki/MicroservicePrerequisites.html
% https://www.martinfowler.com/bliki/EvolutionarySOA.html
% https://ui.adsabs.harvard.edu/abs/2019arXiv190604702F/abstract

% https://www.oreilly.com/library/view/monolith-to-microservices/9781492047834/
% https://www.torocloud.com/podcast/microservices-for-modern-software-development-james-lewis
% https://samnewman.io/offerings/workshops/monolith-to-microservices-workshhop/
% https://www.infoq.com/podcasts/monolith-microservices/
% https://duckduckgo.com/?q=Stefan+Tilkov+microservices&t=osx&ia=web
% https://duckduckgo.com/?q=Guerilla+SOA&t=osx&ia=web
% https://duckduckgo.com/?q=Michael+Nygard+verb&t=osx&ia=web

% https://www.youtube.com/watch?v=zzMLg3Ys5vI
